<html>
    <head>
        <title>Transactions in postlock</title>
        <style>
            h1, h2 {border-bottom: 1px solid #CCC;}
            a.toc_heading_1 { padding-left: 10px;font-size:18px;}
            a.toc_heading_2 { padding-left: 20px;font-size:14px;}
            a.toc_heading_3 { padding-left: 30px;font-size:12px;}
            a.toc_heading_4 { padding-left: 40px;font-size:10px;}
            div.toc {padding-top: 12px;padding-bottom: 12px;}
            a.toc_numbering {color: #ccc;}
            dt {font-weight: bold;}
            dd {font-style: italic; border-left: 2px solid #ccc; padding-left: 4px;}
            p.h1, h1 {padding-left: 10px;}
            p.h2, h2 {padding-left: 20px;}
            p.h3, h3 {padding-left: 30px;}
            p.h4, h4 {padding-left: 40px;}
            pre {background-color: #eee; padding: 8px;}

        </style>
        <script type="text/javascript" src="jquery-1.5.2.js"></script>
        <script type="text/javascript">
            // based on http://www.jankoatwarpspeed.com/post/2009/08/20/Table-of-contents-using-jQuery.aspx
            var generate_toc = function(spec) {
                var my = {
                    text: $(spec.text_container),
                    toc: $(spec.toc_container || $(spec.text_container).children('div.toc')),
                    add_numbering: spec.add_numbering===true,
                    fun: {
                        traverse: function() {
                            var level = 1, counters = [0,0,0,0,0,0];
                            my.text.children("h1, h2, h3, h4, h5, h6").each(function(heading_id) {
                                var h = $(this), level = parseInt(h.attr('tagName').slice(1)), num, i, h_text = h.html();
                                counters[level -1]++;
                                for (i = level; i < counters.length; i++) counters[i] = 0;
                                num = counters.slice(0,level).join('.');
                                my.toc.append("<a href='#heading" + heading_id + "' class='toc_heading_" + level + "'>" + num + ' ' + h_text + "</a><br />");
                                if (my.add_numbering) h.html('<a class="toc_numbering" name="heading'+heading_id+'">' + num + '</a>' + ' ' + h_text);
                                if (h.next()[0] && h.next()[0].tagName.toUpperCase() === 'P') h.next().addClass('h'+level);
                            });
                        }
                    }
                };
                if (my.toc && my.toc.length > 0) {
                    my.fun.traverse();
                }
            };

            $(document).ready(function() {
                generate_toc({
                    text_container: 'body',
                    add_numbering: true
                });
            });
        </script>
    </head>
    <body>
        <b>Specification for transactions in postlock</b><br />
        PLEASE UPDATE THIS DOCUMENT IF THERE ARE CHANGES IN THE PROTOCOL<br />
        Author: Peter Neumark &lt;<i>neumark at postlock dot org</i>&gt;<br />
        Last Modified: -<br />

        <div class="toc"></div>
        <h1>Introduction</h1>
        <h2>About postlock</h2>
        <p>Postlock is a system allowing processes running on different computers to access a globally shared state
        space without the need to explicitly lock objects or perform low-level synchronization. Postlock has an
        optimisitic concurrency model, meaning each client can modify the shared state without consulting with other
        clients or the server.<br />
        Each client maintains their own copy of the global state. Clients must apply changes to their local copy
        first. Once the local modification is complete, the changes are sent to the postlock server which broadcasts the changes to all clients, effectively making the changes global.
        </p>
        <h2>Transactions</h2>
        <p>Changes to global state are expressed as operations on data structures (an example would be
        <code>insert</code> on a list). In order to avoid corruption of the global state, these operations are grouped
        into transactions, which have traditional <a href="http://en.wikipedia.org/wiki/ACID">ACID properties</a>.
        The server places all incoming transactions into a queue, and runs them one at a time. Each transaction may
        succeed or fail depending on the current global state.
        </p>
        <h2>Operational transformations</h2>
        <p>
        Each client may send the server a transaction at any point in time. Client A will perform some local operation
        and send it to the server as a transaction. Simultaneously, Client B does the same. If B's transaction reaches
        the server before A's, and both clients perform operations on the same part of the global state, it is possible
        for A's transaction to be out of date. This means that applying A's transaction "as is" would yield a different
        state for the server than client A's local state after the operation. In order to fix client A's out of date
        transaction so its operations have the same result as they did for client A, 
        an <a href="http://en.wikipedia.org/wiki/Operational_transformation">Operational
        Transformation</a>(OT) must be applied to the operations within A's transaction.
        </p>
        <h2>Related work</h2>
        <p>The concurrency model used by postlock is influenced by the implementation used by <a
        href="http://www.waveprotocol.org/whitepapers">google wave</a>. The fact that Wave was not a commerical success,
        is not due to the underlying technology, which is quite solid. For a more detailed explanation about how Wave
        uses OT, <a
        href="http://www.codecommit.com/blog/java/understanding-and-applying-operational-transformation">check out this
        article</a>. The field of OT is quite mature, preceding Wave by more than a decade. The most important
        publication in the discipline from Postlock's point of view is <a href="http://doi.acm.org/10.1145/215585.215706">High-latency, low-bandwidth windowing in the Jupiter collaboration system</a>.
        </p>
        <h2>Scope of this document</h2>
        <p>This document describes the transaction protocol used by postlock to propagate
        state change information between clients and the server. In particular, it addresses:
            <ol>
                <li>The semantics of transactions</li>
                <li>The message format used to encode transactions</li>
                <li>OT rules for the different data types used by postlock</li>
                <li>Success scenarios</li>
                <li>Failure scenarios</li>
            </ol>
        </p>
        <h2>Definition of terms</h2>
        <p>
            The following terms have specific meaning within postlock:
            <dl>
                <dt>server state</dt>
                    <dd>Like each client, the postlock server also has its own copy of global state. Each time the
                    server applies a transaction, it reaches a new state. The different versions of ther server's state
                    are identified by integers.</dd>
                <dt>unacknowledged state</dt>
                    <dd>After applying an operation, a client enters an unacknolwedged state. The client will remain in
                    the unacknowledged state until it receives either positive or negative acknolwedgement from the
                    server (after which it will enter a server state).</dd>
                <dt>transaction</dt>
                    <dd>A message with a pre-defined format containing a set of operations to be applied to a specific server state. If the receiver of the transaction
                    is in a different state than the one the transaction was created for, then the receiver must perform
                    OT to arrive at a transaction applicable in its current state.</dd>
                <dt>participant</dt>
                    <dd>A process connected to the postlock session which can exchange messages with the other participants.
                    All postlock clients are participants. The state server is also a participant.</dd>
            </dl>
        </p>

        <h1>Transaction semantics</h1>
        <h2>ACID properties</h2>
        <p>Transactions in postlock fulfill the ACID properties:
        <table>
            <tr><td>Atomicity</td><td>If any of the operations fail within a transaction, then the entire transaction is
            discarded and global state is not modified.</td></tr>
            <tr><td>Consistency</td><td>Postlock makes few guarantees about the contents of its data types, but they
            are stricly enforced (eg. no dictionary may have two values attached to the same key).</td></tr>
            <tr><td>Isolation</td><td>Transactions are executed serially, the success of a transaction depends only on
            the current shared state.</td></tr>
            <tr><td>Durability</td><td>Transactions are saved to Mnesia by postlock before they are executed, so
            postlock has the same durability properties as mnesia.</td></tr>
        </table>
        </p>
        <h2>How transactions work</h2>
        <p>
        To understand how transactions are created and executed, its useful to consider the entire chain of actions
        taken to ensure that all clients arrive at the same shared state. Let's consider a case where we have two
        clients, Alice and Bob, using an application which is built atop postlock:
        <ol>
            <li>Initially, the system is synchronized: each client is in the same state as the
            server. We will call this "server state 1".</li>
            <li>Alice clicks a button in the GUI of her postlock application.</li>
            <li>The application requests a change in local state through the postlock client API.</li>
            <li>The postlock client commits the operation locally and creates a transaction message which contains the
            details of the operation as well as the last state the client shared with the server ("server state 1").
            Alice's postlock client is now in "unacknowledged state 1".</li>
            <li>The newly created transactions is placed in the outgoing queue. Since there are no transactions awaiting
            acknowledgement, it is immediately sent to the state server, typically participant 1 in the postlock session.</li>
            <li>The server checks whether or not it needs to apply OT to the transaction before executing it. Since the
            transaction applies to "server state 1", which is the server's current state, it attempts to execute the
            transaction as it was received.</li>
            <li>The transaction is executed in a separate context so the server's state is not affected in the case of
            failure. If the transaction is successfully executed, the modified objects are copied from the transaction's
            context into the server's copy of global state, and the server's state is incremented to "server state 2".</li>
            <li>The server broadcasts the transaction it has applied to the other participants in the session. A field
            is added, which allows Alice's postlock client to identify the transaction as its own.</li>
            <li>Alice's client changes its state to "server state 2", and empties the outgoing transaction queue.</li>
            <li>Bob's client receives the transaction which will take its local copy of shared state to "server state
            2"</li>
            <li>Since Bob has no unacknowledged transactions, the transaction it received from the server can be applied
            as-is.</li>
            <li>After applying the transaction and modifying it's state revision to "server state 2", Bob's client calls
            a callback function in the application code, notifying it of the fact that an object in the shared state has
            been modified.</li>
            <li>The application is notified through the callback to update the GUI, and Bob sees Alice's
            modification</li>
            </li>
        </ol>
        The end-to end propogation of state change in postlock takes lots of small steps. This document describes:
        <ul>
            <li>The format of the transaction message created in step 4.</li>
            <li>The application of OT by the server in step 6.</li>
            <li>In step 7, the possible reasons for failure of a transaction, and the resulting actions of the server.</li>
            <li>The format of the server's outgoing transaction message in step 8, as well as the details of the
            broadcasting mechanism.</li>
            <li>The client's use of OT (would replace step 11 above).</li>
        </ul>
        </p>

        <h1>Message format</h1>
        <p>
            Postlock uses the <a href="http://www.json.org/">JSON</a> representation of data internally. Work is ongoing to allow clients to use
            other encodings (<a href="http://thrift.apache.org">thrift</a> for example). Still, the "official"
            representation of postlock messages is JSON, and all other formats must have clearly defined transformations
            which convert their data into JSON messages.
        </p>
        <h2>Postlock message</h2>
        <p>
            Transactions are standard postlock messages with the following format:
            <pre>
            {
                id: /* integer - message id */,
                from: /* integer - originating participant id */,
                to: /* integer - destination participant id */,
                type: 'transaction',
                body: /* transaction object format, see below */
            }
            </pre>
            Only the <code>body</code> field has a special format in transaction messages. The remaining fields are
            populated the same way as for any other message. It is recommended to use "transaction" as the type of
            transaction messages, but this is currently not enforced.<br />
            The body field has the following format:
            <pre>
            {
                in_response_to: /* string - optional - used for acknowledgment of transactions */,
                state_version: /* integer - identifies a version of server state */,
                ops: [ /* operation description */ ]
            }
            </pre>
            The <code>in_response_to</code> field has the format "participant id.message id", for example "5.2". That
            particular value indicates that the transaction encoded in the current message is actually the same
            transaction as the one sent by participant 5 with message id 2. The in_response_to field is necessary
            because the message sent by the server contains operations which have potentially been modified by OT. When
            participant 5 receives this message, it will not execute the enclosed operations (even if they look
            unfamiliar because of the OT), instead it will remove the transaction message with message id 2 from the
            outgoing transaction queue, since it has been acknowledged by the server.<br />
            The last field of the transaction body is a list of operation objects, which in turn have the following
            format:
            <pre>
            {
                oid: /* integer - optional - object id of subject of operation */
                cmd: /* string - command to run on object */
                params: [] /* arbitrary JSON data - optional */
            }
            </pre>
            Each postlock data type has a set of operations which can be used to modify its state. Invoking such an
            operation requires the oid field to be set and the cmd field to have the proper command name. The oid field
            is marked optional because it is not required for creation/deletion of objects (in which case the oid of the
            object will be in the params array).
            </p>
            <h3>Example postlock message</h3>
            <p>
            The acceptable list items in the params field depend on what type of command is executed. Typically, parameters
            are simple integers and strings, but in theory they could be arbitrarily complex JSON expressions.<br />
            The following example message is sent from a client to the state server and changes the contents of a data
            object:
            <pre>
            {
                id: 1,
                from: 3,
                to: 1,
                type: 'transaction',
                body: {
                    state_version: 1,
                    ops: [
                        {
                            oid: "0.0",
                            cmd: "set",
                            params: ["the new value"]
                        }
                    ]
                }
            }
            </pre>
            Assuming that the transaction was successfully executed, the server would broadcast the following message:
            <pre>
            {
                id: 6,
                from: 1,
                to: 7,
                type: 'transaction',
                body: {
                    in_response_to: "3.1",
                    state_version: 1,
                    ops: [
                        {
                            oid: "0.0",
                            cmd: "set",
                            params: ["the new value"]
                        }
                    ]
                }
            }
            </pre>
            The server's acknowledgement can have any message id &gt; the client's original message id.
            </p>
        <h1>OT</h1>


        Postlock participants (both client and server) maintain their own copy of shared state, allowing them to perform any operation locally.  This allows developers to create extremely responsive collaborative applications and frees them from the burden of locking
            shared objects. Since each participant can perform any operation independently, their copies of shared state will gradually diverge 
            until the next synchronization with the server. This document describes the synchronization mechanizm which guarantees that the local
            state of each client follows the state of the postlock server. In a nutshell, the protocol has the following steps:
            <ol>
            <li>Participant A makes a local modification, and sends this modification to the state server as a transaction.</li>
            <li>Any number of participants may send modifications to the server which are executed before A's message.</li>
            <li>After receiving A's message, the server transforms it to take into account all the other transactions processed in step 2</li>
            <li>The server sends A the result of its transaction along with any modifications committed by other participants in step 2. If A's transaction was successfully applied then the other participants also receive A's transaction.</li>
            </ol>
            <br />
            Note that it is possible to simply poll the postlock state server for the value of an object so keeping a local copy of state is not 
            mandatory. This functionality is useful for building interfaces to languages with request-based execution models (eg. php) but normal
            participants have much to loose by taking this route.
        </p>

        <h1>Transactions in postlock</h1>
            <h2>Terms used in this document</h2>
<dl>
<dt>oid</dt><dd>Abbreviation of Object IDentity. A simple string with the format of "X.Y", where both X and Y are nonnegative integers. 
X is the id of the participant which created the object, while Y is a counter. OID's are guaranteed to be unique. </dd>
</dl>
<h2>Scope of this document</h2>
This document describes the process by which a postlock participant can modify shared state.
Emphasis is placed on the operational transform, which allows the server to run out of date transactions
unless they come into conflict with later transactions. Most of the examples in this file follow the simple template
of 
<ol>
<li>Client A sends the server a transaction.</li>
<li>Client B sends the server a transaction.</li>
<li>The server gets A's transaction, applies it, and notifies both clients (B discards the server's message, since
it no longer applies in B's current state).</li>
<li>The server gets B's transaction which is based on one state prior to the server's current state. It applies 
the operational transform to the message and -if successful- runs the resulting modified operations.</li>
</ol>
This is the <em>simplest</em> scenario in which operational transformations are necessary. More complex situations
are handled the same way (for example if several clients send transactions to the server before B's message arrives).
Generally OT is needed when the state server receives transactions with a starting state older than that state
server's current state. In the template above, the difference between the transaction's start state and the
state server's state is a single transaction. When the start state is several transactions behind the state server's
current state, then the postlock server applies the steps used in the following examples for each transaction. Thus,
the multiple transaction OT is simply a chain of OT's applied in sequence for each transaction which the sender of the
outdated transaction has not yet applied.
<h2>Operations in postlock</h2>
Shared state is a tree-like collection of postlock's managed data types (currently lists, dictionaries and data).
Each managed type has its own set of applicable operations.<br />
Changes are distributed among participants as <em>transactions</em>, which contain a list of <em>operations</em>.
Certain operations are guaranteed to be applicable in any state: for example, creating a new object of any type
will always work. Most operations either outright fail or require a transformation if another user applies the wrong
operations first. Examples:
<h3>Example 1: transaction failure in order to avoid data loss</h3>
The following example shows how operations which lead to data loss fail by default, preventing dangerous writes.
Let's assume a <code>data</code> object, with oid <code>0.0</code> exists, its contents initially set to <code>null</code>.
<ol>
    <li>Client A sets the state to be <code>1</code> with the following message:
        <pre>
            {
                from: 2 // Client A is 2
                to: 1   // the state server is 1
                type: transaction
                body: {
                    tid: "0:0.1",
                    ops: [{
                        oid: "0.0",
                        cmd: "set",
                        params: [1] // 'set' takes only one parameter, the new value.
                    }]
                }
            }
        </pre>
    </li>
    <li>Just as A's transaction reaches the state server, client B sends an operation which
        modifies the same object, but gives it a different value:
        <pre>
            {
                from: 3 // Client B is 3 
                to: 1   // the state server is 1
                type: transaction
                body: {
                    tid: "0:0.1",
                    ops: [{
                        oid: "0.0",
                        cmd: "set",
                        params: [2]
                    }]
                }
            }
        </pre>
    </li>
    <li>The state server gets A's message first, applies it, and notifies both clients. Naturally, B will 
        discard the message, since its state is no longer in 0 (the starting state for the transaction).
        Then, the state server gets B's message. It can see that B's message is slightly out of date, since
        the state server is in state 1 now, while B's transaction advances state only to 0.1.
    </li>
    <li>
        The state server transforms each operation in B's transaction to be applicable in its current state.
        The last transaction that touched object "0.0" in the state server is "0:1". B's transaction is
        "0:0.1", Since the ending state of B's transaction is older than the state of object in the state server,
        we know someone else has changed the object without B's knowledge. Allowing B's 'set' to continue
        would result in data loss.  As a result, B's set will fail.
    </li>
    <li>
        The state server must notify B of the transaction's outcome. It will construct a message that takes
        B's state back to 0, then on to 1 (undoing B's 0.1 state). A slight optimization is possible: instead
        of undoing <em>all</em> operations, only the operations not overridden by applied transactions are
        undone. In our example, the single operation 'set' is in fact overridden, so the state server issues
        a single set with the new value:
        <pre>
            {
                from: 1
                to: 3
                type: transaction
                body: {
                    tid: "0.1:1",
                    result: {
                        ok: false,
                        failed_op: 0,
                        reason: 102     // just an example error code, meant to indicate "out of date"
                    },
                    ops: [{
                        oid: "0.0",
                        cmd: "set",
                        params: [1]
                    }]
                }
            }
        </pre>
    </li>
    <li>
        Upon receiving the state server's response to its transaction, client B has two options. It can either
        decide to dicard its transaction, keeping "0.0" state 1. The other option is to re-run the transaction.
        Since B's state has been moved to 1, the transaction it now sends to the server will have a tid of "1:1.1",
        which will override client A's original transaction. The correct choice is determined by the application's
        logic, there is no innately correct action.
    </li>
</ol>
<h3>Example 2: failure due to conflict</h3>
Some transactions will fail because the operational transform is not possible. The following example demonstrates such a case.
The operations in this example will be applied on a <code>list</code> object (oid: 0.0) with initial value <code>["0.5", "0.1"]</code>.
Note: postlock lists only contain references to other postlock objects, no actual user data is present in a list directly.
<ol>
    <li>
        Client A sends the server a transaction which deletes both elements in the list:
        <pre>
            {
                from: 2,
                to: 1,
                type: transaction
                body: {
                    tid: "0:0.1",
                    ops: [{
                        oid: "0.0",
                        cmd: "remove",
                        params: [1]
                    },
                    {
                        oid: "0.0",
                        cmd: "remove",
                        params: [0]
                    }]
                }
            }
        </pre>
    </li>
    <li>Client B sends the server a transaction in which it attempts to append data object (oid: 3.7) to the list. Although
        the javascript API may expose an <code>append(item)</code> function, an <code>insert</code> command is
        sent in the transaction.
        <pre>
            {
                from: 3,
                to: 1,
                type: transaction
                body: {
                    tid: "0:0.1",
                    ops: [{
                        oid: "0.0",
                        cmd: "insert",
                        params: [2, "3.7"]
                    }]
                }
            }
        </pre>
    </li>
    <li>The usual step 3: the server receives and applies A's message, informs both clients (but B discards the message). 
        Then the server gets B's message, on which it must apply OT to make it applicable in the current state.
        The OT will try to map the old position 2 to a list to its new position. This will fail, as the lists length is
        currently 0.
    </li>
    <li>
        The state server must notify B of the transaction's outcome. The server's reply will
        undo B's <code>insert</code>, which moves B back to state 0, and the delete list items 1 and 2,
        which advances B's state to 1:
        <pre>
            {
                from: 1
                to: 3
                type: transaction
                body: {
                    tid: "0.1:1",
                    result: {
                        ok: false,
                        failed_op: 0,
                        reason: 103     // just an example error code, meant to indicate "no such list position"
                    },
                    ops: [{
                        oid: "0.0",
                        cmd: "remove",
                        params: [2]
                    },
                    {
                        oid: "0.0",
                        cmd: "remove",
                        params: [1]
                    },
                    {
                        oid: "0.0",
                        cmd: "remove",
                        params: [0]
                    }]
                }
            }
        </pre>
        Note: removing elements starting from the back of the list and moving towards the front is pretty straight forward. It's also possible to
        move in the opposite direction, this would require remove(0) operations. Although they look identical, each of them would remove a different
        element in the list.<br />
        Another thing to note: in practice, B's insert of object 3.7 will often be preceded by the creation of object 3.7. By placing the create and
        the insert in a single transaction, the rollback of the transaction (due to the insert's failure) will guarantee that the state space is
        not polluted with unused objects.
    </li>
</ol>
<h3>Example 3: Successfully applied OT</h3>
The following example demonstrates the flow of messages among postlock participants when one of the transactions received
by the state server is out of date and thus requires OT to be applied to the current state. The clients in this example
will operate on a <code>list</code> (oid: 0.0), with the initial value of ["1.1"].

<ol>
<li>Client A prepends item 2.1 to the list:
        <pre>
            {
                from: 2,
                to: 1,
                type: "transaction",
                body: {
                    tid: "0:0.1",
                    ops: [{
                        oid: "0.0",
                        cmd: "insert",
                        params: [0, "2.1"]
                    }]
                }
            }
        </pre>
</li>
<li>Client B appends an item (oid: 3.1) to the list:
        <pre>
            {
                from: 3,
                to: 1,
                type: "transaction",
                body: {
                    tid: "0:0.1",
                    ops: [{
                        oid: "0.0",
                        cmd: "insert",
                        params: [1, "3.1"]
                    }]
                }
            }
        </pre>
</li>
<li> The state server receives both messages. As a response to the first message, the state server sends
the following transactions:
    <pre>
            { // Acknowledgement of A's transaction.
                from: 1,
                to: 2, 
                type: "transaction",
                body: {
                    tid: "0.1:1",
                    result: {
                        ok: true,
                    },
                    ops: []
                }
            }

            { // Note: this message will be discarded by B.
                from: 1,
                to: 3, 
                type: "transaction",
                body: {
                    tid: "0:1",
                    ops: [{
                        oid: "0.0",
                        cmd: "insert",
                        params: [0, "2.1"]
                    }]
                }
            }
 
    </pre>
</li>
<li>Since the B's transaction has a start state of 0 and the state server's curernt state is 1, the server
will apply OT to the insert within B's transaction. Since the difference between the transaction's start state
(0) and the state server's current state (1) is an insert(0, ...) operation, any list positions in B's message
which are &gt; 0 must be incremented by 1.
<pre>
                        params: [1, "3.1"]  =&gt; params: [2, "3.1"]
                        state 2 for object 0.0: ["2.1", "1.1", "3.1"]
</pre>
</li>
<li>
The state server must notify both clients that B's transaction was successfully applied. It send B and acknowledgement of its transaction
and also re-transmit A's transaction so B will arrive in state 2. A will receive a transformed version of B's transaction which can
be applied in state 1:
<pre>
            {
                from: 1,
                to: 3,
                type: "transaction",
                body: {
                    tid: "0.1:2",
                    result: {
                        ok: true,
                    },
                    ops: [{         // note: in state 0.1, B's version of the list is ["1.1", "3.1"]
                        oid: "0.0",
                        cmd: "insert",
                        params: [0, "2.1"]
                    }]
                }
            }

            {
                from: 1,
                to: 2,
                type: "transaction",
                body: {
                    tid: "1:2",
                    ops: [{
                        oid: "0.0",
                        cmd: "insert",
                        params: [2, "3.1"]
                    }]
                }
            }
</pre>
How did the state server construct the reply sent to B? In order to bring B up to state 2, A's transaction must be applied,
but B can't apply it in it's original form, since B's state is 0.1, not 0 (the starting state of A's transaction). Again,
the state server must perform an OT which makes A's transaction applicable in B's 0.1 state.<br />
B's 0.1 state differs from state 0 by the <code>insert(1, "3.1")</code> (note that this is the operation applied by B locally,
not the version applied by the state server). Since list positions &lt; 1 are not affected, A's transaction needs no modification,
it can be sent as is.
</li>
</ol>
</body>
</html>
